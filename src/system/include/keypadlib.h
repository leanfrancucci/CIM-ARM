#ifndef __KEYPADLIB__H_
#define __KEYPADLIB__H_

#include <keypad.h>

#define MAX_NAVIGATION_KEYS		 16
#define MAX_NUMERIC_KEYS		   11
#define MAX_ALPHANUMERIC_KEYS	 13

 
/*
 *			Unless otherwise stated, functions
 *			returns 0 on success, negative error code or -1  and
 *			error code in errno if fail. 
 */


/*
 *	kp_init_open
 * 		Opens the keypad driver
 * 		If mode = O_NONBLOCK the drivers opens in non blocking mode.
 */
int kp_init_open(int mode);

/*
 *	kp_nonblock_open
 * 		Opens the keypad driver in non block mode
 */
int kp_nonblock_open(void);
	
/*
 *	kp_open
 * 		Opens the keypad driver
 */
int kp_open(void);

/*
 * kp_close
 * 		Closes the keypad driver
 */
int kp_close(void);

/*
 * kp_read
 * 		Reads data from the driver.
 *		Blocks the proccess if no data is available.
 *		If there is data available in the driver queue (or when data is available)
 *		then the driver copies the data in buf, and the functions returns the
 *		size of the data copied.
  * 	Returns the number of bytes read if success or a negative value if fail.
 * 		(the driver stores the chars received in a 16 bytes queue)
 */
int kp_read(char *buf, int count);

/*
 * kp_getc
 * 	Reads one char from the device.
 * 	If no data available blocks the caller.
 * 	
 */
int kp_getc(void);

/*
 * kp_kbhit
 *	Test the keypad for available data.
 *	If data available then returns 1, otherwise returns 0.
 */
int kp_kbhit(void);

/*
 * kp_gets
 * 	Reads size - 1 characteres from the driver until EOF or '/n' is found.
 * 	Stores '\0' in size - 1.
 */
char *kp_gets(char *s, int size);

/*
 * kp_gets
 * 	Reads size - 1 characteres from the driver.
 * 	Stores '\0' in size - 1.
 */
char *kp_getstring(char *s, int size);

/*
 * kp_write
 * 		Writes commands to the driver.
 */
int kp_write(const char *buf, int count);

/*
 * kp_set_mode
 * 		Sets the mode of use of the driver.
 * 		mode is KP_RAW or KP_XLATE
 */
int kp_set_mode(int mode);

/*
 * kp_get_mode
 * 		Gets the actual mode of use of the driver.
 */
int kp_get_mode(void);

/*
 * kp_set_rawmode
 * 		Sets the driver in KP_RAW mode
 */
int kp_set_raw_mode(void);


/*
 * kp_set_scancode_evt
 * 		Sets OnKeyPressed event or OnKeyReleased event for scancode.
 */
int kp_set_scancode_evt(int scancode, int event);


/*
 *
 *
 */
int kp_set_onreleased_evt_on(int scancode);

/*
 *
 *
 */
int kp_set_onreleased_evt_off(int scancode);
/*
 *
 *
 */
int kp_is_onreleased_evt_on(int scancode);

/*
 *
 *
 */
int kp_set_onpressed_evt_on(int scancode);

/*
 *
 *
 */
int kp_set_onpressed_evt_off(int scancode);

/*
 *
 *
 */
int kp_is_onpressed_evt_on(int scancode);

/*
 * kp_set_xlate_mode
 * 		Sets the driver in KP_XLATE mode
 */
int kp_set_xlate_mode(void);

/*
 * kp_set_numericmode
 * 		Sets the driver to generates numeric  and navigation chars only.
 * 		The chars generated by the driver are:
 * 			numeric group: 			'0'..'9' and
 * 			navigation group: 	'\x1B' (escape) ,
 * 													'\n' (enter) ,
 * 													'\8' (delete),
 * 													'<' (left arrow),
 * 													'>' (right arrow) and
 * 													'\1' PRG key.
 */
int kp_set_numeric_mode(void);

/*
 * kp_set_alphanummode
 * 		Sets the driver to generates alphanumeric and navigation chars.
 * 		The chars generated by the driver are:
 * 			alpha group:			'A-Z' and ' ';
 * 			numeric group: 		'0'-'9' and
 * 			navigation group: see kp_set_numericmode
 */
int kp_set_alphanum_mode(void);

/*
 * kp_set_navigation_mode
 * 	Sets navigation group mode:
 * 			navigation group: 	'\x1B' (escape) ,
 * 								'\n' (enter) ,
 * 								'\8' (delete),
 * 								'<' (left arrow),
 * 								'>' (right arrow) and
 * 								'\1' PRG key.
 */
int kp_set_navigation_mode(void);

/*
 * kp_set_mapscancode
 * 		Maps the keychars characters and the scancode argument.
 * 		The driver will generate each character in keychars on every keypressed
 event
 * 		of the scancode arg.
 */
int kp_set_mapscancode(int scancode, char *keychars);

/*
 * kp_get_mapscancode
 * 		Gets the scancode mapping.
 */
int kp_get_mapscancode(int scancode, char *keychars);

/*
 * kp_set_sendxlatespecialkey
 *	Sets the scancode to send the xlate special key char
 *
 */
int kp_set_sendxlatespecialkey(int scancode, int on);

/*
 * kp_set_sendspecialkey_on;
 *	Sets on the scancode to send xlate special key
 *
 */
int kp_set_sendxlatespecialkey_on(int scancode);
	
/*
 * kp_set_sendspecialkey_off;
 *	Sets off the scancode to send xlate special key
 *
 */
int kp_set_sendxlatespecialkey_off(int scancode);
	
/*
 *  kp_get_sendxlatespecialkey
 *  	Returns 1 if the scancode must send the special xlate key char
 *
 */
int kp_get_sendxlatespecialkey(int scancode);

/*
 * kp_set_xlatetimeout
 * 		Sets the timeout, in miliseconds,  for xlate use mode.
 */
int kp_set_xlatetimeout(int timeout);

/*
 * kp_get_xlatetimeout
 * 		Gets the timeout of the xlate use mode.
 * 		Returns the xlate timeout value if success or a negative value if fail.
 */
int kp_get_xlatetimeout(void);

/*
 * kp_set_xlatespecialkey
 * 		Sets the special key of the xlate use mode.
 */
int kp_set_xlatespecialkey(int specialkey);

/*
 * kp_get_xlatespecialkey
 * 		Gets the special key of the xlate use mode.
 * 		Returns the xlate special key value if success or a negative value if fail.
 */
int kp_get_xlatespecialkey(void);

/*
 *
 *
 */
int kp_get_error(void);

/*
 *
 *
 */
char * kp_get_error_msg(int);

#endif




