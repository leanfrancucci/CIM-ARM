#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <keypadlib.h>

	
/*
 *	kp_init_open
 * 		Opens the keypad driver
 * 		If mode = O_NONBLOCK the drivers opens in non blocking mode.
 */
int 
kp_init_open(int mode)
{
	return 0;	
}


/*
 *	kp_nonblock_open
 * 		Opens the keypad driver in non block mode
 */
int 
kp_nonblock_open(void)
{
	return kp_init_open(0);
}

/*
 *	kp_open
 * 		Opens the keypad driver
 */
int 
kp_open(void)
{
	return kp_init_open(0);
}

/*
 * kp_close
 * 		Closes the keypad driver
 */
int 
kp_close(void)
{	
	return 0;
}

/*
 * kp_read
 * 		Reads data from the driver.
 *		Blocks the proccess if no data is available.
 *		If there is data available in the driver queue (or when data is available)
 *		then the driver copies the data in buf, and the functions returns the
 *		size of the data copied.
  * 	Returns the number of bytes read if success or a negative value if fail.
 * 		(the driver stores the chars received in a 16 bytes queue)
 */
int kp_read(char *buf, int count)
{		
	return 0;	
}


/*
 * kp_getc
 * 	Reads one char from the device.
 * 	If no data available blocks the caller.
 * 	
 */
int 
kp_getc(void)
{
	return getchar();
	/*
int	getche (void);
int	kbhit (void);
*/
}

/*
 * kp_kbhit
 *	Test the keypad for available data.
 *	If data available then returns 1, otherwise returns 0.
 */
int 
kp_kbhit(void)
{
	return 0; 	
}


/*
 * kp_gets
 * 	Reads size - 1 characteres from the driver until EOF or '/n' is found.
 * 	Stores '\0' in size - 1.
 */
char *
kp_gets(char *dst, int size)
{	
	return  NULL;
}

/*
 * kp_getsitring
 * 	Reads size - 1 characteres from the driver.
 * 	Stores '\0' in size - 1.
 */
char *
kp_getstring(char *dst, int size)
{
	return  NULL;
}

/*
 * kp_write
 * 		Writes commands to the driver.
 */
int 
kp_write(const char *buf, int count)
{
	return 0;
}

/*
 * kp_set_mode
 * 		Sets the mode of use of the driver.
 * 		mode is KP_RAW or KP_XLATE
 */
int 
kp_set_mode(int mode)
{	
	return 0;
}

/*
 * kp_get_mode
 * 		Gets the actual mode of use of the driver.
 */
int 
kp_get_mode(void)
{
	return 0;
}

/*
 * kp_set_rawmode
 * 		Sets the driver in KP_RAW mode
 */
int 
kp_set_raw_mode(void)
{
	return 0;
}


/*
 * kp_set_scancode_event
 * 		Sets OnKeyPressed event or OnKeyReleased event for scancode.
 */
int 
kp_set_scancode_evt(int scancode, int event)
{
	return 0;		
}

/*
 *
 */
int 
kp_set_onreleased_evt_on(int scancode)
{
	return 0;
}

/*
 *
 */
int 
kp_set_onreleased_evt_off(int scancode)
{
	return 0;
}

/*
 *
 */
int 
kp_is_onreleased_evt_on(int scancode)
{
	return 0;
}

/*
 *
 */
int 
kp_set_onpressed_evt_on(int scancode)
{
	return 0;
}

/*
 *
 */
int 
kp_set_onpressed_evt_off(int scancode)
{
	return 0;
}

/*
 *
 */
int 
kp_is_onpressed_evt_on(int scancode)
{
	return 0;
}

/*
 * kp_set_xlatemode
 * 		Sets the driver in KP_XLATE mode
 */
int 
kp_set_xlate_mode(void)
{
	return 0;
}

/*
 * kp_set_numericmode
 * 		Sets the driver to generates numeric  and navigation chars only.
 * 		The chars generated by the driver are:
 * 			numeric group: 			'0'..'9' and
 * 			navigation group: 	'\x1B' (escape) ,
 *						'\n' (enter) ,
 *						'\8' (delete),
 *						'<' (left arrow),
 *						'>' (right arrow) and
 *						'\1' PRG key.
 */
int 
kp_set_numeric_mode(void)
{
	return 0;
}

/*
 * kp_set_alphanummode
 * 		Sets the driver to generates alphanumeric and navigation chars.
 * 		The chars generated by the driver are:
 * 			alpha group:			'A-Z' and ' ';
 * 			numeric group: 		'0'-'9' and
 * 			navigation group: see kp_set_numericmode
 */
int 
kp_set_alphanum_mode(void)
{
	return 0;	
}

/*
 * kp_set_navigation_mode
 * 	Sets navigation group mode:
 * 			navigation group: 	'\x1B' (escape) ,
 * 						'\n' (enter) ,
 * 						'\8' (delete),
 * 						'<' (left arrow),
 * 						'>' (right arrow) and
 * 						'\1' PRG key.
 */
int
kp_set_navigation_mode(void)
{
	return 0;
}

/*
 * kp_set_mapscancode
 * 		Maps the keychars characters and the scancode argument.
 * 		The driver will generate each character in keychars on every keypressed event
 * 		of the scancode arg.
 */
int 
kp_set_mapscancode(int scancode, char *keychars)
{
	return 0;
}

/*
 * kp_get_mapscancode
 * 		Gets the scancode mapping.
 */
int
kp_get_mapscancode(int scancode, char *keychars)
{
	return 0;
}

/*
 * kp_set_sendxlatespecialkey
 *	Sets the scancode to send the xlate special key char
 *
 */
int 
kp_set_sendxlatespecialkey(int scancode, int on)
{
	return 0;
}

/*
 * kp_set_sendxlatespecialkey_on;
 *	Sets on the scancode to send xlate special key
 *
 */
int 
kp_set_sendxlatespecialkey_on(int scancode)
{
	return 0;
}	

/*
 * kp_set_sendxlatespecialkey_off;
 *	Sets off the scancode to send xlate special key
 *
 */
int 
kp_set_sendxlatespecialkey_off(int scancode)
{	
	return 0;
}

/*
 *  kp_get_sendxlatespecialkey
 *  	Returns 1 if the scancode must send the special xlate key char
 *
 */
int 
kp_get_sendxlatespecialkey(int scancode)
{
	return 0;
}

/*
 * kp_set_xlatetimeout
 * 		Sets the timeout, in miliseconds,  for xlate use mode.
 */
int 
kp_set_xlatetimeout(int timeout)
{
	return 0;
}

/*
 * kp_get_xlatetimeout
 * 		Gets the timeout of the xlate use mode.
 * 		Returns the xlate timeout value if success or a negative value if fail.
 */
int 
kp_get_xlatetimeout(void)
{
	return 0;
}

/*
 * kp_set_xlatespecialkey
 * 		Sets the special key of the xlate use mode.
 */
int 
kp_set_xlatespecialkey(int specialkey)
{
	return 0;
}

/*
 * kp_get_xlatespecialkey
 * 		Gets the special key of the xlate use mode.
 * 		Returns the xlate special key value if success or a negative value if fail.
 */
int 
kp_get_xlatespecialkey(void)
{
	return 0;
}


/*
 *
 *
 */
int
kp_get_error(void)
{
	return 0;
}

/*
 *
 *
 */
char *
kp_get_error_msg(int err)
{
	return NULL;
}

  
